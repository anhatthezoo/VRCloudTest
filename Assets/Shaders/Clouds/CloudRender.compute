#pragma kernel CSMain
#pragma enable_d3d11_debug_symbols
#include "Packages/com.unity.render-pipelines.universal/ShaderLibrary/RealtimeLights.hlsl"
#include "Math.hlsl"

#define PLANET_RADIUS float(6000000.0)
#define PLANET_CENTER float3(0.0, -PLANET_RADIUS, 0.0)
#define CLOUD_VOLUME_THICKNESS float(3000.0)
#define CLOUD_LAYER_BEGIN float(2000.0)
#define CLOUD_INNER_SHELL_RADIUS (PLANET_RADIUS + CLOUD_LAYER_BEGIN)
#define CLOUD_OUTER_SHELL_RADIUS (CLOUD_INNER_SHELL_RADIUS + CLOUD_VOLUME_THICKNESS)
#define CLOUD_SCALE (1.0 / (CLOUD_LAYER_BEGIN + CLOUD_VOLUME_THICKNESS))

#define CLOUDS_AMBIENT_TOP float3(255, 255, 255) * (1. / 255.0)
#define CLOUDS_AMBIENT_BOTTOM float3(93, 106, 115) * (1. / 255.0)

// x: scale
// y,z : x, y offsets
#define WEATHER_TEX_MOD float3(0.00001, 0.5, 0.5)
#define SAMPLE_RANGE uint2(64, 128)

static const float3 NOISE_KERNEL[] = {
    float3(0.295787, 0.952936, -0.066508),
    float3(0.206517, 0.959319, 0.192502),
    float3(0.087877, 0.994795, -0.051581),
    float3(-0.214029, 0.93444, 0.28463),
    float3(-0.289995, 0.952647, -0.091464),
    float3(0.022786, 0.970513, -0.239968)
};

RWTexture2D<float4> OutRT;
int _RTWidth;
int _RTHeight;
float4x4 _CameraToWorld;
float4x4 _CameraInverseProjection;

Texture3D _CloudBase;
SamplerState sampler_CloudBase;
Texture3D _CloudDetail;
SamplerState sampler_CloudDetail;
Texture2D _CurlNoise;
SamplerState sampler_CurlNoise;
Texture2D _WeatherMap;
SamplerState sampler_WeatherMap;

// float _Time;
// float3 _SunDirection;
// float3 _SunLightColor;
float _DensityThreshold;
float _CoverageMultiplier;
float _HighFreqNoiseStrength;

float getHeightFractionForPoint(float3 pos) {
    float heightFraction = round((distance(pos, PLANET_CENTER) - CLOUD_INNER_SHELL_RADIUS)) / (CLOUD_OUTER_SHELL_RADIUS - CLOUD_INNER_SHELL_RADIUS);

    return saturate(heightFraction);
}

float3 sampleWeather(float3 pos) {
    float2 uv = (pos.xz * WEATHER_TEX_MOD.x) + WEATHER_TEX_MOD.yz;
    return _WeatherMap.SampleLevel(sampler_WeatherMap, uv, 0.0).rgb;
}

float getLayerDensityByType(float heightFrac, float type) {
    float cumulus = max(0.0, remap(heightFrac, 0.0, 0.2, 0.0, 1.0) * remap(heightFrac, 0.7, 0.9, 1.0, 0.0));
    float stratocumulus = max(0.0, remap(heightFrac, 0.0, 0.2, 0.0, 1.0) * remap(heightFrac, 0.2, 0.7, 1.0, 0.0)); 
    float stratus = max(0.0, remap(heightFrac, 0.0, 0.1, 0.0, 1.0) * remap(heightFrac, 0.2, 0.3, 1.0, 0.0)); 

    float d1 = lerp(stratus, stratocumulus, clamp(type * 2.0, 0.0, 1.0));
    float d2 = lerp(stratocumulus, cumulus, clamp((type - 0.5) * 2.0, 0.0, 1.0));
    return lerp(d1, d2, type);
}

float sampleCloudDensity(float3 pos, float heightFrac, float3 weatherData, bool fast) {
    pos += heightFrac * float3(1.0, 0.0, 0.0) * 500.0;
    pos += (float3(1.0, 0.0, 0.0) + float3(0.0, 0.1, 0.0)) * _Time.y * 3.0;
    pos *= CLOUD_SCALE;

    float4 lowFreqNoises = _CloudBase.SampleLevel(sampler_CloudBase, pos * 1.0, 0.0).rgba; 
    float lowFreqFBM = 
        (lowFreqNoises.g * .625) + 
        (lowFreqNoises.b * .25) + 
        (lowFreqNoises.a * .125);

    float baseCloud = remap(lowFreqNoises.r, -(1.0 - lowFreqFBM), 1.0, 0.0, 1.0);
    float layerDensity = getLayerDensityByType(heightFrac, .5);

    baseCloud = smoothstep(0.4, 0.65, baseCloud);
    baseCloud *= layerDensity;

    float cloudCoverage = weatherData.r * _CoverageMultiplier;
    baseCloud = remap(baseCloud, saturate(cloudCoverage), 1.0, 0.0, 1.0);
    baseCloud *= cloudCoverage;

    if (!fast) {
        float2 curlNoise = _CurlNoise.SampleLevel(sampler_CurlNoise, pos.xz * 0.01, 0.0);
        pos.xz += curlNoise.xy * (1.0 - heightFrac);
        
        float3 highFreqNoises = _CloudDetail.SampleLevel(sampler_CloudDetail, pos * 2.0, 0.0).rgb;
        float highFreqFBM = 
            (highFreqNoises.r * 0.625) +
            (highFreqNoises.g * 0.25) + 
            (highFreqNoises.b * 0.125);
            
        float highFreqNoiseMod = lerp(highFreqFBM, 1.0 - highFreqFBM, saturate(heightFrac * 10.0));
        float finalCloud = remap(baseCloud, highFreqNoiseMod * _HighFreqNoiseStrength, 1.0, 0.0, 1.0);

        return saturate(finalCloud);
    }

    return saturate(baseCloud);
}

float sampleDensityAlongCone(float3 startPos, float3 sunDir) {
    float lightStepSize = 64.;
    float3 lightStep = sunDir * lightStepSize;
    float coneSpread = length(lightStep);
    float densityAlongCone = 0.0;
    float3 pos = startPos;
    float heightFrac;

    for (int i = 0; i < 6; i++) {
        pos += lightStep + (coneSpread * NOISE_KERNEL[i] * float(i));

        heightFrac = getHeightFractionForPoint(pos);
        float3 weatherData = sampleWeather(pos);

        if (densityAlongCone < 0.3) {
            densityAlongCone += max(0, sampleCloudDensity(pos, heightFrac, weatherData, false));
        } else {
            densityAlongCone += max(0, sampleCloudDensity(pos, heightFrac, weatherData, true));
        }
    }

    return densityAlongCone * lightStepSize;
}

float HenyeyGreenstein(float g, float mu) {
    float g2 = g * g;
    return (1.0 - g2) / (pow(1.0 + g2 - 2.0 * g * mu, 1.5) * 4.0 * PI);
}

float computeLightEnergy(float lightDensity, float heightFrac, float mu) {
    float beers = max(exp(-lightDensity * 2.), (exp(-lightDensity * 0.25 * 2.0) * 0.25));
    float depthProbability = 0.05 + pow(lightDensity, remap(heightFrac, 0.15, .85, .3, 1.0));
    float verticalProbability = pow(remap(heightFrac, 0.07, .14, 0.15, 1.0), 0.8);
    float inScatter = saturate(depthProbability * verticalProbability);
    float phase = lerp(HenyeyGreenstein(0.6, mu), HenyeyGreenstein(-0.2, mu), 0.5);

    return 2.0 * beers * inScatter * phase;
}

float4 computeClouds(float3 traceStart, float3 traceEnd, float3 rayDir) {
    float traceLength = length(traceEnd - traceStart);
    uint sampleCount = lerp(SAMPLE_RANGE.x, SAMPLE_RANGE.y, 
                            saturate((traceLength - CLOUD_VOLUME_THICKNESS) / CLOUD_VOLUME_THICKNESS));
    float stepSize = traceLength / float(sampleCount);
    float3 pos = traceStart;

    const Light sun = GetMainLight();
    float mu = dot(sun.direction, rayDir);

    float cloudTest = 0.0;
    int zeroDensitySampleCount = 0;
    float3 scattering = float3(0.0, 0.0, 0.0);
    float transmittance = 1.0;


    [loop]
    for (uint i = 0; i < sampleCount; i++) {
        float heightFrac = getHeightFractionForPoint(pos);
        float3 weatherData = sampleWeather(pos);

        float density = sampleCloudDensity(pos, heightFrac, weatherData, false);

        if (cloudTest > 0.0) {
            float density = sampleCloudDensity(pos, heightFrac, weatherData, false);

            if (density == 0.0) {
                zeroDensitySampleCount++;
            }

            if (zeroDensitySampleCount != 6) {
                if (density > _DensityThreshold) {
                    float lightDensity = sampleDensityAlongCone(pos, sun.direction);
                    float3 ambient = lerp(CLOUDS_AMBIENT_BOTTOM, CLOUDS_AMBIENT_TOP, smoothstep(0.0, 1.0, heightFrac));

                    float T = exp(-density * stepSize);
                    float lightEnergy = computeLightEnergy(lightDensity, heightFrac, mu);

                    float3 luminance = (ambient + (sun.color * 2.5) * lightEnergy) * density;
                    float3 integScatter = (luminance - luminance * T) / max(0.0000001, density); 
                    
                    scattering += transmittance * integScatter;                      
                    transmittance *= T;

                    if (transmittance < 0.05) {
                        transmittance = 0.0;
                        break;
                    }
                }

                pos += stepSize * rayDir;
            } else {
                cloudTest = 0.0;
                zeroDensitySampleCount = 0;
            }
        } else {
            cloudTest = sampleCloudDensity(pos, heightFrac, weatherData, true);

            if (cloudTest == 0.0) {
                pos += stepSize * rayDir;
            }
        }

        pos += stepSize * rayDir;
    }

    return float4(scattering, transmittance);
}

[numthreads(8,8,1)]
void CSMain (uint3 id : SV_DispatchThreadID)
{
    float2 uv = float2((id.xy + float2(0.5, 0.5)) / float2(_RTWidth, _RTHeight) * 2.0 - 1.0);
    float3 camOrigin = float3(0.0, 0.0, 0.0);
    float3 rayOrigin = mul(_CameraToWorld, float4(camOrigin, 1.0)).xyz;
    float3 rayDir = mul(_CameraInverseProjection, float4(uv, 0.0, 1.0)).xyz;
    rayDir = mul(_CameraToWorld, float4(rayDir, 0.0)).xyz;
    rayDir = normalize(rayDir);

    float3 upDir = normalize(camOrigin - PLANET_CENTER);

    if (dot(upDir, rayDir) < 0.0) {
        OutRT[id.xy] = float4(0, 0, 0, 1);
        return;
    }

    float2 ih = float2(0.0, 0.0);
    bool didHitInnerLayer = raySphereIntersection(
        camOrigin,
        rayDir,
        PLANET_CENTER,
        CLOUD_INNER_SHELL_RADIUS,
        ih
    );

    float2 oh = float2(0.0, 0.0);
    bool didHitOuterLayer = raySphereIntersection(
        camOrigin,
        rayDir,
        PLANET_CENTER,
        CLOUD_OUTER_SHELL_RADIUS,
        oh
    );

    float3 innerLayerHit = camOrigin + (rayDir * ih.x);
    float3 outerLayerHit = camOrigin + (rayDir * oh.x);

    float4 cloudResult = computeClouds(innerLayerHit, outerLayerHit, rayDir);
    float horizonFade = smoothstep(0.0, 0.15, dot(upDir, rayDir));
    cloudResult = lerp(float4(0, 0, 0, 1), cloudResult, horizonFade);
    
    OutRT[id.xy] = float4(cloudResult.rgb, 1.0);
}
